@page "/vaults/{vaultId:guid}"
@using Microsoft.AspNetCore.Authorization
@using noMoreAzerty_front.Dialogs
@using noMoreAzerty_front.Handlers
@using noMoreAzerty_dto.DTOs.Response;
@inject VaultService VaultService
@inject VaultEntryService VaultEntryService
@inject VaultKeyManager KeyManager
@inject NavigationManager Navigation
@inject IDialogService DialogService
@inject ISnackbar Snackbar
@attribute [Authorize]

<PageTitle>Vault Entries</PageTitle>

<MudContainer>
    <MudStack Row="true"
              AlignItems="AlignItems.Center"
              Justify="Justify.SpaceBetween"
              Class="mb-4 w-100">
        <MudText Typo="Typo.h4">
            @Vault?.Name
        </MudText>
        <MudButton StartIcon="@Icons.Material.Filled.Add"
                   Variant="Variant.Filled"
                   Color="Color.Primary"
                   OnClick="OpenCreateVaultEntryDialog">
            New entry
        </MudButton>
    </MudStack>

    @if (isLoading)
    {
        <MudProgressCircular Indeterminate="true" />
    }
    else if (Vault == null)
    {
        <MudText Color="Color.Secondary">Vault not found.</MudText>
    }
    else if (entriesMetadata == null || !entriesMetadata.Any())
    {
        <MudText Color="Color.Secondary">No entries found in this vault.</MudText>
    }
    else
    {
        <MudStack Spacing="2">
            @foreach (var metadata in entriesMetadata)
            {
                <MudPaper Elevation="1"
                          @onclick="() => SelectVaultEntry(metadata.Id)"
                          Class="@($"vault-card {(SelectedEntryId == metadata.Id ? "selected" : "")}")"
                          Style="cursor: pointer;">

                    <MudStack Row="true" AlignItems="AlignItems.Center">
                        <MudText Typo="Typo.subtitle1">
                            @metadata.DecryptedTitle
                        </MudText>

                        <MudSpacer />
                        
                        <MudIconButton Color="Color.Error"
                                       Icon="@Icons.Material.Filled.Delete"
                                       OnClick="@(() => DeleteVaultEntry(metadata.Id, metadata.DecryptedTitle))"/>

                    </MudStack>

                </MudPaper>
            }
        </MudStack>
    }
</MudContainer>

@code {
    [Inject] IJSRuntime JS { get; set; } = default!;
    [Parameter] public Guid VaultId { get; set; }
    
    private GetVaultResponse? Vault { get; set; }
    private List<EntryMetadataViewModel> entriesMetadata = new();
    private Guid? SelectedEntryId;
    private bool isLoading = true;

    // Classe interne pour gérer les métadonnées + titre déchiffré
    private class EntryMetadataViewModel
    {
        public Guid Id { get; set; }
        public string DecryptedTitle { get; set; } = string.Empty;
        public DateTime? CreatedAt { get; set; }
        public DateTime? UpdatedAt { get; set; }
    }

    protected override async Task OnInitializedAsync()
    {
        Vault = VaultService.CurrentVault;

        // Vérifier si le vault est déverrouillé
        if (Vault == null || !KeyManager.IsVaultUnlocked(VaultId))
        {
            Navigation.NavigateTo("/");
            return;
        }

        await LoadEntriesMetadata();
        isLoading = false;
    }

    private async Task LoadEntriesMetadata()
    {
        try
        {
            var metadata = await VaultEntryService.GetEntriesMetadataAsync(VaultId);

            if (metadata == null || !metadata.Any())
            {
                return;
            }

            // Récupérer la clé de chiffrement / déchiffrement
            var keyDerivation = await KeyManager.GetDerivationKeyAsync(VaultId);

            // Déchiffrer uniquement les titres
            foreach (var entry in metadata)
            {
                var decryptedTitle = await JS.InvokeAsync<string>(
                    "decryptAesGcm",
                    keyDerivation,
                    VaultService.Salt,
                    entry.TitleIV,
                    entry.TitleTag,
                    entry.CipherTitle,
                    100000
                );


                entriesMetadata.Add(new EntryMetadataViewModel
                {
                    Id = entry.Id,
                    DecryptedTitle = decryptedTitle ?? "[Decryption failed]",
                    CreatedAt = entry.CreatedAt,
                    UpdatedAt = entry.UpdatedAt
                });
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to load entries: {ex.Message}", Severity.Error);
        }
    }

    private async Task SelectVaultEntry(Guid entryId)
    {
        SelectedEntryId = entryId;

        try
        {
            // Appel API pour récupérer l'entrée complète (historisation côté serveur)
            var entry = await VaultEntryService.GetEntryByIdAsync(VaultId, entryId);

            if (entry == null)
            {
                Snackbar.Add("Failed to load entry", Severity.Error);
                return;
            }

            // Récupérer la clé de chiffrement / déchiffrement
            var keyDerivation = await KeyManager.GetDerivationKeyAsync(VaultId);

            // Déchiffrer tous les champs
            entry.CipherTitle = await JS.InvokeAsync<string>(
                "decryptAesGcm",
                keyDerivation,
                VaultService.Salt,
                entry.TitleIV,
                entry.TitleTag,
                entry.CipherTitle,
                100000
            );

            entry.CipherUsername = await JS.InvokeAsync<string>(
                "decryptAesGcm",
                keyDerivation,
                VaultService.Salt,
                entry.UsernameIV,
                entry.UsernameTag,
                entry.CipherUsername,
                100000
            );

            entry.CipherUrl = await JS.InvokeAsync<string>(
                "decryptAesGcm",
                keyDerivation,
                VaultService.Salt,
                entry.UrlIV,
                entry.UrlTag,
                entry.CipherUrl,
                100000
            );

            entry.CipherPassword = await JS.InvokeAsync<string>(
                "decryptAesGcm",
                keyDerivation,
                VaultService.Salt,
                entry.PasswordIV,
                entry.PasswordTag,
                entry.CipherPassword,
                100000
            );

            entry.CipherCommentary = await JS.InvokeAsync<string>(
                "decryptAesGcm",
                keyDerivation,
                VaultService.Salt,
                entry.ComentaryIV,
                entry.ComentaryTag,
                entry.CipherCommentary,
                100000
            );

            await OpenEditVaultEntryDialog(entry);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error: {ex.Message}", Severity.Error);
        }
    }

    private async Task OpenCreateVaultEntryDialog()
    {
        var parameters = new DialogParameters
        {
            { "OnSave", EventCallback.Factory.Create<GetVaultEntriesResponse>(this, AddEntry) }
        };

        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Medium, FullWidth = true };

        DialogService.Show<VaultEntryDialog>("Create Entry", parameters, options);
    }

    private async Task OpenEditVaultEntryDialog(GetVaultEntriesResponse entry)
    {
        var parameters = new DialogParameters
        {
            { "Entry", entry },
            { "OnSave", EventCallback.Factory.Create<GetVaultEntriesResponse>(this, UpdateEntry) }
        };

        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Medium, FullWidth = true };

        DialogService.Show<VaultEntryDialog>("Edit Entry", parameters, options);
    }

    private async Task DeleteVaultEntry(Guid entryId, string title)
    {
        bool? confirmed = await DialogService.ShowMessageBox(
            "Confirm deletion",
            $"Are you sure you want to delete the entry '{title}'? This action cannot be undone.",
            yesText: "Delete",
            cancelText: "Cancel"
        );

        if (confirmed != true) return;

        try
        {
            var success = await VaultEntryService.DeleteEntryAsync(VaultId, entryId);

            if (success)
            {
                Snackbar.Add("Entry deleted", Severity.Success);
                entriesMetadata.RemoveAll(e => e.Id == entryId);
                StateHasChanged();
            }
            else
            {
                Snackbar.Add("Failed to delete entry", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error: {ex.Message}", Severity.Error);
        }
    }

    private async Task AddEntry(GetVaultEntriesResponse newEntry)
    {
        entriesMetadata.Clear();
        await LoadEntriesMetadata();
        StateHasChanged();
    }

    private async Task UpdateEntry(GetVaultEntriesResponse updatedEntry)
    {
        entriesMetadata.Clear();
        await LoadEntriesMetadata();
        StateHasChanged();
    }
}